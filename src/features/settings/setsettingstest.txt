import {
  Action,
  AnyAction,
  configureStore,
  Dispatch,
  ThunkAction,
} from "@reduxjs/toolkit";
import settingsReducer, { fetchSettings, setSettings } from "./settingsSlice";
import { getUserFromDatabase } from "@app/util";

jest.mock("@app/util", () => ({
  getUserFromDatabase: jest.fn(),
}));

describe("settingsSlice", () => {
  let store: ReturnType<
    typeof configureStore & {
      dispatch: Dispatch<AnyAction>;
    }
  >;
  const mockUserData = {
    email: "test@test.com",
    name: "Test User",
    notifications: true,
    biography: "This is a test biography.",
  };

  beforeEach(() => {
    store = configureStore({
      reducer: {
        settings: settingsReducer,
      },
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("setSettings", () => {
    const mockSettings = {
      name: "Test User",
      notifications: true,
      biography: "This is a test biography.",
      password: "newPassword",
      oldPassword: "oldPassword",
    };

    it("should handle setSettings correctly", async () => {
      const expectedSettings = {
        email: "",
        password: "",
        notifications: mockSettings.notifications,
        name: mockSettings.name,
        biography: mockSettings.biography,
      };

      try {
        await store.dispatch(setSettings(mockSettings));
      } catch (error) {
        console.log(error);
      }

      const actualSettings = store.getState().settings.settings;
      expect(actualSettings).toEqual(expectedSettings);
    });

    it("should handle setSettings with only password update", async () => {
      const mockPasswordUpdate = {
        password: "newPassword",
        oldPassword: "oldPassword",
      };

      await store.dispatch(setSettings(mockPasswordUpdate));

      const actualSettings = store.getState().settings.settings;
      expect(actualSettings.password).toEqual(mockPasswordUpdate.password);
    });

    it("should handle setSettings with errors", async () => {
      const errorMessage = "Error setting user data";
      (getUserFromDatabase as jest.Mock).mockRejectedValueOnce(
        new Error(errorMessage)
      );

      await expect(
        store.dispatch(setSettings(mockSettings))
      ).resolves.toMatchObject({
        error: expect.objectContaining({ message: "Rejected" }),
      });
    });
  });
});

type RootState = ReturnType<typeof store.getState>;
export type AppThunk<ReturnType = void> = ThunkAction<
  ReturnType,
  RootState,
  unknown,
  Action<string>
>;
